
#include "elevator.h"


struct elevator construct_elevator(int cf, int ap, int ip) {
	
	struct elevator e;
		
	e.direction = NA;
	e.state = IDLE;
	
	e.active_stopwatch = 0;
	e.idle_stopwatch = 0;
	
	e.current_floor = cf;
	e.active_period = ap;
	e.idle_period = ip;
	
	e.downward_inbound = construct_empty_priority_queue();
	e.upward_inbound = construct_empty_priority_queue();
	e.downward_outbound = construct_empty_priority_queue();
	e.upward_outbound = construct_empty_priority_queue();
	e.record = construct_empty_priority_queue();
	
	return e;
	
	
}

struct elevator construct_random_elevator(int cfr[2], int apr[2], int ipr[2]) {
	
	struct elevator e;
	
	e.direction = NA;
	e.state = IDLE;
	
	e.active_stopwatch = 0;
	e.idle_stopwatch = 0;
	
	e.current_floor = cfr[0] + (rand() % (cfr[1] - cfr[0] + 1));
	e.active_period = apr[0] + (rand() % (apr[1] - apr[0] + 1));
	e.idle_period = ipr[0] + (rand() % (ipr[1] - ipr[0] + 1));
	
	e.downward_inbound = construct_empty_priority_queue();
	e.upward_inbound = construct_empty_priority_queue();
	e.downward_outbound = construct_empty_priority_queue();
	e.upward_outbound = construct_empty_priority_queue();
	e.record = construct_empty_priority_queue();
	
	return e;
	
}

int is_elevator_empty(struct elevator* e) {
	
	if (	
			e->downward_inbound.head == NULL &&
			e->upward_inbound.head == NULL &&
			e->downward_outbound.head == NULL &&
			e->upward_outbound.head == NULL
			
		)
			
		return 1;
		
	else
		
		return 0;
	
	
}


void push_node_inbound_elevator(struct elevator* e, struct node n, int t) {
	// assumes the client's next floor is not the same as current floor
	
	if (n.c.current_floor < e->current_floor)
		push_priority_queue(&e->downward_inbound, n, cmp_node_c_current_floor, 1);
	else
		push_priority_queue(&e->upward_inbound, n, cmp_node_c_current_floor, 0);
}

void push_node_outbound_elevator(struct elevator* e, struct node n, int t) {
	
	n.c.time_punches[1] = t;

	if (n.c.next_floor < e->current_floor)
		push_priority_queue(&e->downward_outbound, n, cmp_node_c_next_floor, 1);
	else
		push_priority_queue(&e->upward_outbound, n, cmp_node_c_next_floor, 0);

	if (e->direction == DOWN)
		pop_priority_queue(&e->downward_inbound);
	else
		pop_priority_queue(&e->upward_inbound);

}

void push_node_record_elevator(struct elevator* e, struct node n, int t) {

	n.c.time_punches[2] = t;
	
	push_priority_queue(&e->record, n, cmp_node_c_time_punch_2, 1);

	if (e->direction == DOWN)
		pop_priority_queue(&e->downward_outbound);
	else
		pop_priority_queue(&e->upward_outbound);

}

int should_change_direction_elevator(struct elevator* e) {

	if (e->direction == DOWN) {
		if (is_empty_priority_queue(&e->downward_inbound) && is_empty_priority_queue(&e->downward_outbound))
			return 1;
	else
		if (is_empty_priority_queue(&e->upward_inbound) && is_empty_priority_queue(&e->upward_outbound))
			return 1;

	return 0;


}
void change_direction_elevator(struct elevator* e) {

	if (e->direction == DOWN)
		e->direction = UP;
	else
		e->direction = DOWN;
}


void free_elevator(struct elevator* e) {
	
	free_priority_queue(&e->downward_inbound);
	free_priority_queue(&e->upward_inbound);
	free_priority_queue(&e->downward_outbound);
	free_priority_queue(&e->upward_outbound);
	free_priority_queue(&e->record);
	
	free(e);
	
}
